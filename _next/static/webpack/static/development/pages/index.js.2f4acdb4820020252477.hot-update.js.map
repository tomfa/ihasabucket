{"version":3,"file":"static/webpack/static/development/pages/index.js.2f4acdb4820020252477.hot-update.js","sources":["webpack:///./sections/Questionare.tsx","webpack:///./utils/urls.ts"],"sourcesContent":["import useQuestions from '../questions/useQuestions';\nimport { Section } from '../components/utils';\nimport RadioGroup from '../components/forms/RadioGroup';\nimport CheckboxGroup from '../components/forms/CheckboxGroup';\nimport { BOOL_VALUE, QUESTION_ID } from '../enums';\nimport { CheckboxAnswer, DropdownAnswer, RadioAnswer } from '../types';\nimport TextInput from '../components/forms/TextInput';\nimport DropDown from '../components/forms/Dropdown';\nimport { getNormalizedAnswer, hasAnswered } from '../questions/utils';\nimport Infrastructure from './Infrastructure';\nimport { useUrlState } from '../utils/urls';\n\nconst Questionare = () => {\n  const {\n    answers,\n    renderQuestions,\n    answerQuestion,\n    hasAnsweredAll,\n  } = useQuestions();\n  useUrlState();\n  return (\n    <Section>\n      {renderQuestions.map((question) => {\n        if (question.type === 'radio') {\n          const answer = answers[question.id] as RadioAnswer;\n          return (\n            <RadioGroup\n              id={question.id}\n              key={question.id}\n              options={question.options}\n              selectedOption={answer}\n              onChange={(value) => answerQuestion(question.id, value)}\n              title={question.title}\n              description={question.description}\n            />\n          );\n        }\n        if (question.type === 'dropdown') {\n          const answer = answers[question.id] as DropdownAnswer;\n          return (\n            <DropDown\n              id={question.id}\n              key={question.id}\n              options={question.options}\n              selectedOption={answer}\n              onChange={(value) => answerQuestion(question.id, value)}\n              title={question.title}\n              description={question.description}\n            />\n          );\n        }\n        if (question.type === 'checkbox') {\n          const answer = answers[question.id] as CheckboxAnswer;\n          return (\n            <CheckboxGroup\n              id={question.id}\n              key={question.id}\n              options={question.options}\n              selectedOptions={answer}\n              onChange={(value) => answerQuestion(question.id, value)}\n              title={question.title}\n              description={question.description}\n            />\n          );\n        }\n        if (question.type === 'text') {\n          return (\n            <TextInput\n              id={question.id}\n              key={question.id}\n              placeholder={question.placeholder}\n              placeholders={question.placeholders}\n              onSubmit={(value) => answerQuestion(question.id, value)}\n              title={question.title}\n              description={question.description}\n            />\n          );\n        }\n        throw new Error(`Unexpected question type in ${question}`);\n      })}\n      {hasAnsweredAll && (\n        <Infrastructure\n          webApp={hasAnswered(answers, QUESTION_ID.storageType, 'webapp')}\n          shared={hasAnswered(answers, QUESTION_ID.aclPublic, BOOL_VALUE.TRUE)}\n          staging={hasAnswered(\n            answers,\n            QUESTION_ID.stagingEnv,\n            BOOL_VALUE.TRUE\n          )}\n          staticPage={hasAnswered(\n            answers,\n            QUESTION_ID.webappIsStatic,\n            BOOL_VALUE.TRUE\n          )}\n          bucketName={getNormalizedAnswer(answers, QUESTION_ID.domainName)}\n          region={getNormalizedAnswer(answers, QUESTION_ID.region)}\n        />\n      )}\n    </Section>\n  );\n};\n\nexport default Questionare;\n","import { ParsedUrlQuery } from 'querystring';\nimport { NextRouter, useRouter } from 'next/router';\nimport { useCallback, useEffect, useState } from 'react';\n\ntype DataValue = string | boolean | number;\nexport type Data = { [key: string]: DataValue | DataValue[] };\n\nexport const useUrlState = () => {\n  const router: NextRouter = useRouter();\n  const [urlData, setUrlData] = useState<Data>(\n    getDataFromUrlQuery(router.query)\n  );\n  useEffect(() => {\n    const newData = getDataFromUrlQuery(router.query);\n    console.log('LOAD DATA');\n    console.log(urlData);\n    if (hasChanged(urlData, newData)) {\n      console.log('setting it');\n      setUrlData(newData);\n    }\n  }, [router.query]);\n  const updateUrlData = useCallback(\n    (data: Data) => {\n      const newData = filterInvalidValues({\n        ...mapToQuery(urlData),\n        ...mapToQuery(data),\n      });\n      router.push(router.route, newData);\n    },\n    [router.route, urlData]\n  );\n  return { urlData, updateUrlData, setUrlData };\n};\n\nconst filterInvalidValues = (data: ParsedUrlQuery): ParsedUrlQuery =>\n  Object.entries(data).reduce((map, [key, value]) => {\n    if (value) {\n      return { ...map, [key]: value };\n    }\n    return map;\n  }, {});\n\nfunction valueIsNumber(value: string) {\n  return !Number.isNaN(parseInt(value))\n}\n\nconst parseToValue = (value: string): DataValue => {\n  if (value.toLowerCase() === 'false') {\n    return false;\n  }\n  if (value.toLowerCase() === 'true') {\n    return true;\n  }\n  if (valueIsNumber(value)) {\n    return parseInt(value);\n  }\n  return value;\n};\n\nconst mapToQuery = (data: Data): ParsedUrlQuery => {\n  return Object.entries(data).reduce((map, [key, value]) => {\n    const stringValue =\n      value instanceof Array ? value.map((v) => String(v)) : String(value);\n    return {\n      ...map,\n      [key]: stringValue,\n    };\n  }, {});\n};\n\nconst getDataFromUrlQuery = (parsedUrlQuery: ParsedUrlQuery): Data => {\n  // Note: This ignores empty string values, e.g. would not support ?webapp\n  const urlState: Data = {};\n  Object.entries(parsedUrlQuery).forEach(([query, value]) => {\n    if (value) {\n      if (value instanceof Array) {\n        urlState[query] = value.map(parseToValue);\n      } else {\n        urlState[query] = parseToValue(value);\n      }\n    }\n  });\n  return urlState;\n};\n\nconst hasChanged = (oldData: Data, newData: Data): boolean => {\n  // Note: This thinks that '1' === 1 and 'false' === false\n  return !!Object.keys(oldData).find(\n    (key) => String(newData[key]) !== String(oldData[key])\n  );\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAKA;AAKA;AACA;AAdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrGA;AACA;AAKA;AACA;AACA;AAFA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AANA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;;;A","sourceRoot":""}