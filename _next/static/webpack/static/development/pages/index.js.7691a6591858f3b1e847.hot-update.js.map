{"version":3,"file":"static/webpack/static/development/pages/index.js.7691a6591858f3b1e847.hot-update.js","sources":["webpack:///./questions/utils.ts"],"sourcesContent":["import { BOOL_VALUE, QUESTION_ID, VALUES } from \"../enums\";\nimport {\n  Answer,\n  AnswerMap,\n  CheckboxAnswer,\n  DropdownAnswer,\n  Question,\n  QuestionDisplayCondition,\n  QuestionType,\n  RadioAnswer,\n  TextAnswer,\n} from '../types';\nimport { questions, questionMap } from './data';\n\nexport const getDefaultAnswer = (question: Question): Answer => {\n  if (question.type === QuestionType.TEXT) {\n    return question.defaultValue || null;\n  }\n  if (\n    question.type === QuestionType.RADIO ||\n    question.type === QuestionType.DROPDOWN\n  ) {\n    return (\n      question.options.find((o) => o?.value === question.defaultValue) || null\n    );\n  }\n  if (question.type === QuestionType.CHECKBOX) {\n    const defaultValue = question.defaultValue;\n    if (!defaultValue) {\n      return [];\n    }\n    if (typeof defaultValue === 'string' || typeof defaultValue === 'number') {\n      return question.options.filter((o) => o.value === defaultValue);\n    }\n    if (defaultValue instanceof Array) {\n      return question.options.filter((o) =>\n        (defaultValue as string[]).includes(o.value)\n      );\n    }\n    return null;\n  }\n};\n\nexport const hasAnswered = (questionId: QUESTION_ID, answers: AnswerMap, value: string | BOOL_VALUE | VALUES): boolean => {\n  const question = questionMap[questionId];\n  if (question.type === QuestionType.RADIO) {\n    const answer = answers[questionId] as RadioAnswer;\n    return answer.value === value;\n  }\n  if (question.type === QuestionType.CHECKBOX) {\n    const answer = answers[questionId] as CheckboxAnswer;\n    return !!answer.find((o) => o.value === value);\n  }\n  if (question.type === QuestionType.DROPDOWN) {\n    const answer = answers[questionId] as DropdownAnswer;\n    return answer.value === value;\n  }\n  if (question.type === QuestionType.TEXT) {\n    const answer = answers[questionId] as TextAnswer;\n    return answer === value;\n  }\n}\n\nconst isFulfilled = (\n  condition: QuestionDisplayCondition,\n  answers: AnswerMap\n): boolean => hasAnswered(condition.questionId, answers, condition.value)\n\nconst shouldSkip = (question: Question, answers: AnswerMap): boolean => {\n  return (\n    question.showIf && !!question.showIf.find((c) => !isFulfilled(c, answers))\n  );\n};\n\nconst getLastRenderIndex = (\n  answers: AnswerMap,\n  answeredQuestions: QUESTION_ID[],\n  startAtIndex = 0\n) => {\n  const question = questions[startAtIndex];\n  if (!question) {\n    return startAtIndex;\n  }\n  const questionMissingAnswer =\n    !answeredQuestions.includes(question.id) && !shouldSkip(question, answers);\n  if (questionMissingAnswer) {\n    return startAtIndex;\n  }\n  return getLastRenderIndex(answers, answeredQuestions, startAtIndex + 1);\n};\n\nexport const getQuestionsToRender = (\n  answers: AnswerMap,\n  answeredQuestions: QUESTION_ID[]\n): Question[] => {\n  const questionsToRender: Question[] = [];\n  const lastRenderIndex = getLastRenderIndex(answers, answeredQuestions);\n  questions.slice(0, lastRenderIndex + 1).forEach((question) => {\n    if (!shouldSkip(question, answers)) {\n      questionsToRender.push(question);\n    }\n  });\n\n  return questionsToRender;\n};\n"],"mappings":";;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;A","sourceRoot":""}