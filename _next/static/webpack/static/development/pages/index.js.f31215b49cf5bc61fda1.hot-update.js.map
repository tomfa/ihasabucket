{"version":3,"file":"static/webpack/static/development/pages/index.js.f31215b49cf5bc61fda1.hot-update.js","sources":["webpack:///./sections/Questionare.tsx"],"sourcesContent":["import { useCallback, useEffect, useState } from 'react';\nimport { Section } from '../components/utils';\nimport RadioGroup from '../components/forms/RadioGroup';\nimport CheckboxGroup from '../components/forms/CheckboxGroup';\nimport {\n  CheckboxSelectionMap,\n  generateDefaultCheckboxSelectedOptions,\n  generateDefaultRadioSelectedOptions,\n  questions,\n  RadioSelectionMap,\n  TextAnswerMap,\n} from '../utils/questions';\nimport { BOOL_VALUE, QUESTION_ID, VALUES } from '../enums';\nimport {\n  DropdownQuestion,\n  InputQuestion, Option,\n  Question,\n  RadioQuestion\n} from \"../types\";\nimport TextInput from '../components/forms/TextInput';\nimport DropDown from '../components/forms/Dropdown';\nimport questionData from '../utils/questionData';\nimport Infrastructure from './Infrastructure';\nimport { useUrlState } from '../utils/urls';\n\nconst Questionare = () => {\n  const { urlData, updateUrlData } = useUrlState();\n  useEffect(() => {\n    console.log(urlData);\n  }, [urlData]);\n\n\n  const [selectedRadioOptions, setRadioAnswers] = useState<\n    RadioSelectionMap\n  >(generateDefaultRadioSelectedOptions(questions));\n  const [selectedCheckboxOptions, setCheckboxAnswers] = useState<\n    CheckboxSelectionMap\n  >(generateDefaultCheckboxSelectedOptions(questions));\n  const [textAnswers, setTextAnswers] = useState<TextAnswerMap>({});\n  const setTextAnswer = (questionId: QUESTION_ID, value: string | null) => {\n    setTextAnswers(prev => ({...prev, [questionId]: value}));\n    updateUrlData({ [questionId]: value })\n  }\n  const setRadioAnswer = (questionId: QUESTION_ID, option:  Option | null) => {\n    setRadioAnswers(prev => ({...prev, [questionId]: option}));\n    updateUrlData({ [questionId]: option.value })\n  }\n  const setCheckboxAnswer = (questionId: QUESTION_ID, options:  Option[]) => {\n    setCheckboxAnswers(prev => ({...prev, [questionId]: options}));\n    updateUrlData({ [questionId]: options.map(o => o.value) })\n  }\n\n  const [questionRenderCount, setQuestionRenderCount] = useState<number>(0);\n  const hasSelected = useCallback(\n    (questionId: QUESTION_ID, value: string | VALUES): boolean => {\n      if (value === VALUES.NOT_EMPTY) {\n        return hasAnswered(questionId);\n      }\n      const question = questions.find((q) => q.id === questionId);\n      if (!question) {\n        throw Error(`Missing question for ${questionId}`);\n      }\n      if (question.type === 'text') {\n        return textAnswers[questionId] && textAnswers[questionId] === value;\n      }\n      if (!question.options.filter((o) => o.value === value)) {\n        throw Error(`Question ${questionId} does not have option ${value}`);\n      }\n      if (question.type === 'radio' || question.type === 'dropdown') {\n        return selectedRadioOptions[question.id]?.value === value;\n      }\n      if (question.type === 'checkbox') {\n        return !!selectedCheckboxOptions[question.id].find(\n          (o) => o.value === value\n        );\n      }\n    },\n    [selectedRadioOptions, selectedCheckboxOptions, questions]\n  );\n  const getTextAnswer = (question: InputQuestion) => {\n    return textAnswers[question.id];\n  };\n  const getRadioAnswer = (question: DropdownQuestion | RadioQuestion) => {\n    return selectedRadioOptions[question.id];\n  };\n\n  const hasAnswered = useCallback(\n    (questionId: QUESTION_ID): boolean => {\n      const question = questions.find((q) => q.id === questionId);\n      if (!question) {\n        throw Error(`Missing question for ${questionId}`);\n      }\n      if (question.type === 'radio' || question.type === 'dropdown') {\n        return selectedRadioOptions[question.id]?.value != null;\n      }\n      if (question.type === 'checkbox') {\n        return selectedCheckboxOptions[question.id].length > 0;\n      }\n      if (question.type === 'text') {\n        return Object.keys(textAnswers).includes(questionId);\n      }\n    },\n    [selectedRadioOptions, selectedCheckboxOptions, questions]\n  );\n  const shouldSkip = useCallback(\n    (question: Question): boolean =>\n      question.showIf &&\n      !!question.showIf.find((c) => !hasSelected(c.questionId, c.value)),\n    [hasSelected]\n  );\n  const hasAnsweredAll = !questions.find(\n    (q) => !hasAnswered(q.id) && !shouldSkip(q)\n  );\n  return (\n    <Section>\n      {questions.slice(0, questionRenderCount + 1).map((question) => {\n        const indexOfAllQuestions = questions.indexOf(question);\n        const isLast = indexOfAllQuestions === questionRenderCount;\n        if (shouldSkip(question)) {\n          if (isLast) {\n            setQuestionRenderCount((q) => q + 1);\n          }\n          return null;\n        }\n        if (question.type === 'radio') {\n          const answerValue = selectedRadioOptions[question.id] || null;\n          return (\n            <RadioGroup\n              id={question.id}\n              key={question.id}\n              options={question.options}\n              selectedOption={answerValue}\n              onChange={(value) => {\n                setQuestionRenderCount((c) =>\n                  Math.max(c, indexOfAllQuestions + 1)\n                );\n                setRadioAnswer(question.id, value);\n              }}\n              title={question.title}\n              description={question.description}\n            />\n          );\n        }\n        if (question.type === 'checkbox') {\n          return (\n            <CheckboxGroup\n              id={question.id}\n              key={question.id}\n              options={question.options}\n              selectedOptions={selectedCheckboxOptions[question.id] || []}\n              onChange={(value) => {\n                setQuestionRenderCount((c) =>\n                  Math.max(c, indexOfAllQuestions + 1)\n                );\n                setCheckboxAnswer(question.id, value);\n              }}\n              title={question.title}\n              description={question.description}\n            />\n          );\n        }\n        if (question.type === 'text') {\n          return (\n            <TextInput\n              id={question.id}\n              key={question.id}\n              placeholder={question.placeholder}\n              placeholders={question.placeholders}\n              onSubmit={(value) => {\n                setTextAnswer(question.id, value.trim().toLowerCase())\n                setQuestionRenderCount((c) =>\n                  Math.max(c, indexOfAllQuestions + 1)\n                );\n              }}\n              title={question.title}\n              description={question.description}\n            />\n          );\n        }\n        if (question.type === 'dropdown') {\n          const answerValue = selectedRadioOptions[question.id] || null;\n          return (\n            <DropDown\n              id={question.id}\n              key={question.id}\n              options={question.options}\n              selectedOption={answerValue}\n              onChange={(value) => {\n                setRadioAnswer(question.id, value);\n                setQuestionRenderCount((c) =>\n                  Math.max(c, indexOfAllQuestions + 1)\n                );\n              }}\n              title={question.title}\n              description={question.description}\n            />\n          );\n        }\n        throw new Error(`Unexpected question type ${question.type}`);\n      })}\n      {hasAnsweredAll && (\n        <Infrastructure\n          webApp={hasSelected(QUESTION_ID.storageType, 'webapp')}\n          shared={hasSelected(QUESTION_ID.aclPublic, BOOL_VALUE.TRUE)}\n          staging={hasSelected(QUESTION_ID.stagingEnv, BOOL_VALUE.TRUE)}\n          staticPage={hasSelected(QUESTION_ID.webappIsStatic, BOOL_VALUE.TRUE)}\n          bucketName={getTextAnswer(questionData['domain-name'])}\n          region={getRadioAnswer(questionData[QUESTION_ID.region]).value}\n        />\n      )}\n    </Section>\n  );\n};\n\nexport default Questionare;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAQA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAaA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AA1BA;AAAA;AAAA;AACA;AA2BA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAAA;AAFA;AAKA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;;;;A","sourceRoot":""}