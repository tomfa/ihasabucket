{"version":3,"file":"static/webpack/static/development/pages/index.js.7f8dae057b005f59c7fd.hot-update.js","sources":["webpack:///./questions/utils.ts"],"sourcesContent":["import { BOOL_VALUE, QUESTION_ID, VALUES } from '../enums';\nimport {\n  Answer,\n  AnswerMap,\n  CheckboxAnswer,\n  DropdownAnswer,\n  Option,\n  Question,\n  QuestionDisplayCondition,\n  QuestionType,\n  RadioAnswer,\n  TextAnswer,\n} from '../types';\nimport { questions, questionMap } from './data';\n\nexport const getDefaultAnswer = (question: Question): Answer => {\n  if (question.type === QuestionType.TEXT) {\n    return question.defaultValue || null;\n  }\n  if (\n    question.type === QuestionType.RADIO ||\n    question.type === QuestionType.DROPDOWN\n  ) {\n    return (\n      question.options.find((o) => o?.value === question.defaultValue) || null\n    );\n  }\n  if (question.type === QuestionType.CHECKBOX) {\n    const defaultValue = question.defaultValue;\n    if (!defaultValue) {\n      return [];\n    }\n    if (typeof defaultValue === 'string' || typeof defaultValue === 'number') {\n      return question.options.filter((o) => o.value === defaultValue);\n    }\n    if (defaultValue instanceof Array) {\n      return question.options.filter((o) =>\n        (defaultValue as string[]).includes(o.value)\n      );\n    }\n    return null;\n  }\n};\n\nexport const normalizeAnswer = (answer: Answer): string => {\n  if (answer === null) {\n    return '';\n  }\n  if (\n    typeof answer === 'string' ||\n    typeof answer === 'number' ||\n    typeof answer === 'boolean'\n  ) {\n    return String(answer);\n  }\n  if (answer instanceof Array) {\n    return (answer as Option[]).map((o) => o.value).join(',');\n  }\n  if (answer.value !== null) {\n    return answer.value;\n  }\n  return '';\n};\n\nexport const getNormalizedAnswer = (\n  answers: AnswerMap,\n  questionId: QUESTION_ID\n): string => {\n  return normalizeAnswer(answers[questionId]);\n};\n\nexport const hasAnswered = (\n  answers: AnswerMap,\n  questionId: QUESTION_ID,\n  value: string | BOOL_VALUE | VALUES | null\n): boolean => {\n  const question = questionMap[questionId];\n  if (question.type === QuestionType.RADIO) {\n    const answer = answers[questionId] as RadioAnswer;\n    if (answer === null) {\n      return value === null;\n    }\n    return answer.value === value;\n  }\n  if (question.type === QuestionType.CHECKBOX) {\n    const answer = answers[questionId] as CheckboxAnswer;\n    if (answer === null) {\n      return value === null;\n    }\n    return !!answer.find((o) => o.value === value);\n  }\n  if (question.type === QuestionType.DROPDOWN) {\n    const answer = answers[questionId] as DropdownAnswer;\n    if (answer === null) {\n      return value === null;\n    }\n    return answer.value === value;\n  }\n  if (question.type === QuestionType.TEXT) {\n    const answer = answers[questionId] as TextAnswer;\n    if (answer === null) {\n      return value === null;\n    }\n    return answer === value;\n  }\n};\n\nconst isFulfilled = (\n  condition: QuestionDisplayCondition,\n  answers: AnswerMap\n): boolean => hasAnswered(answers, condition.questionId, condition.value);\n\nconst shouldSkip = (question: Question, answers: AnswerMap): boolean => {\n  return (\n    question.showIf && !!question.showIf.find((c) => !isFulfilled(c, answers))\n  );\n};\n\nconst getLastRenderIndex = (\n  answers: AnswerMap,\n  answeredQuestions: QUESTION_ID[],\n  startAtIndex = 0\n) => {\n  const question = questions[startAtIndex];\n  if (!question) {\n    return startAtIndex;\n  }\n  const questionMissingAnswer =\n    !answeredQuestions.includes(question.id) && !shouldSkip(question, answers);\n  if (questionMissingAnswer) {\n    return startAtIndex;\n  }\n  return getLastRenderIndex(answers, answeredQuestions, startAtIndex + 1);\n};\n\nexport const getQuestionsToRender = (\n  answers: AnswerMap,\n  answeredQuestions: QUESTION_ID[]\n): Question[] => {\n  const questionsToRender: Question[] = [];\n  const lastRenderIndex = getLastRenderIndex(answers, answeredQuestions);\n  questions.slice(0, lastRenderIndex + 1).forEach((question) => {\n    if (!shouldSkip(question, answers)) {\n      questionsToRender.push(question);\n    }\n  });\n\n  return questionsToRender;\n};\n"],"mappings":";;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAIA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;A","sourceRoot":""}