{"version":3,"file":"static/webpack/static/development/pages/index.js.fcf91460cfeb0a80224b.hot-update.js","sources":["webpack:///./questions/useQuestions.ts","webpack:///./utils/useUrlState.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useState } from 'react';\n\nimport { QUESTION_ID } from '../enums';\nimport { Answer, AnswerMap } from '../types';\nimport {\n  getDefaultAnswer,\n  getQuestionsToRender, normalizeAnswer\n} from \"./utils\";\nimport { questions } from './data';\nimport { useUrlState } from '../utils/useUrlState';\n\nconst useQuestions = () => {\n  const [answeredQuestions, setAnsweredQuestions] = useState<QUESTION_ID[]>([]);\n  const { urlData, updateUrlData } = useUrlState();\n  const [answers, setAnswers] = useState<AnswerMap>({} as AnswerMap);\n  useEffect(() => {\n    if (answeredQuestions.length > 0) {\n      return\n    }\n    const defaultAnswers = questions.reduce(\n      (map, question) => ({\n        ...map,\n        [question.id]: getDefaultAnswer(question, String( urlData[question.id])),\n      }),\n      {} as AnswerMap\n    );\n    setAnsweredQuestions(Object.keys(urlData) as QUESTION_ID[]);\n    setAnswers(defaultAnswers)\n  }, [urlData, answeredQuestions]);\n  const renderQuestions = useMemo(\n    () => getQuestionsToRender(answers, answeredQuestions),\n    [answeredQuestions, answers]\n  );\n  const hasAnsweredAll = !renderQuestions.find(\n    (q) => !answeredQuestions.includes(q.id)\n  );\n  const answerQuestion = useCallback(\n    (questionId: QUESTION_ID, answer: Answer) => {\n      updateUrlData({ [String(questionId)]: normalizeAnswer(answer) });\n      setAnswers((prevAnswers) => ({\n        ...prevAnswers,\n        [questionId]: answer,\n      }));\n      setAnsweredQuestions((qs) => [...qs, questionId]);\n    },\n    [updateUrlData]\n  );\n  return { answers, renderQuestions, answerQuestion, hasAnsweredAll };\n};\n\nexport default useQuestions;\n","import qs, { ParsedUrlQuery } from 'querystring';\nimport { NextRouter, useRouter } from 'next/router';\nimport { useCallback, useEffect, useState } from 'react';\n\ntype DataValue = string | boolean | number;\nexport type Data = { [key: string]: DataValue | DataValue[] };\n\nexport const useUrlState = () => {\n  const router: NextRouter = useRouter();\n  const [urlData, setUrlData] = useState<Data>({});\n  useEffect(() => {\n    const newData = getDataFromUrlQuery(router.query);\n    if (hasChanged(urlData, newData)) {\n      setUrlData(newData);\n    }\n  }, [JSON.stringify(router.query)]);\n  const updateUrlData = useCallback(\n    (data: Data) => {\n      const newData = filterInvalidValues({\n        ...mapToQuery(urlData),\n        ...mapToQuery(data),\n      });\n      setUrlData(newData);\n      router.push(`/?` + qs.stringify(newData));\n    },\n    [urlData]\n  );\n  return { urlData, updateUrlData };\n};\n\nconst filterInvalidValues = (data: ParsedUrlQuery): ParsedUrlQuery =>\n  Object.entries(data).reduce((map, [key, value]) => {\n    if (value) {\n      return { ...map, [key]: value };\n    }\n    return map;\n  }, {});\n\nfunction valueIsNumber(value: string) {\n  return !Number.isNaN(parseInt(value));\n}\n\nconst parseToValue = (value: string): DataValue => {\n  if (value.toLowerCase() === 'false') {\n    return false;\n  }\n  if (value.toLowerCase() === 'true') {\n    return true;\n  }\n  if (valueIsNumber(value)) {\n    return parseInt(value);\n  }\n  return value;\n};\n\nconst mapToQuery = (data: Data): ParsedUrlQuery => {\n  return Object.entries(data).reduce((map, [key, value]) => {\n    const stringValue =\n      value instanceof Array ? value.map((v) => String(v)) : String(value);\n    return {\n      ...map,\n      [key]: stringValue,\n    };\n  }, {});\n};\n\nconst getDataFromUrlQuery = (parsedUrlQuery: ParsedUrlQuery): Data => {\n  // Note: This ignores empty string values, e.g. would not support ?webapp\n  const urlState: Data = {};\n  Object.entries(parsedUrlQuery).forEach(([query, value]) => {\n    if (value) {\n      if (value instanceof Array) {\n        urlState[query] = value.map(parseToValue);\n      } else {\n        urlState[query] = parseToValue(value);\n      }\n    }\n  });\n  return urlState;\n};\n\nconst hasChanged = (oldData: Data, newData: Data): boolean => {\n  return JSON.stringify(oldData) !== JSON.stringify(newData);\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAIA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AAKA;AACA;AACA;AAFA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AANA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}